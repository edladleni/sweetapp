import base64
import requests
from datetime import datetime

from requests.models import Response

class HanaRest():
    _url_path_csrf   = '/sap/hana/xs/dt/base/server/csrf.xsjs'          # url path for csrf token
    _url_path_file   = '/sap/hana/xs/dt/base/file/'                     # url path for file based operations
    _url_path_change = '/sap/hana/xs/dt/base/change/'                   # url path for change ids
    
    def __init__(self, base_url, username, password,jwt = False):
        self._base_url  = base_url

        self._b64_pword = base64.b64encode(bytes(f"{username}:{password}", "ISO-8859-1")).decode("ascii")
        self._auth_header = {"Authorization": f"Basic {self._b64_pword}"}
            
        try:
            api_url = self._base_url + self._url_path_csrf
            csrf_header = {"X-CSRF-TOKEN": "Fetch"}

            # add the csrf_header to the auth_header
            req_header = self._auth_header
            req_header.update(csrf_header)

            response = requests.get(api_url, headers=req_header)
            self._csrf_token = response.headers['X-CSRF-TOKEN']
            self._session_cookie = response.headers['set-cookie']

        except:
            raise
          

    def read_file(self, repo_package, filename):
        api_url =  self._base_url + self._url_path_file + repo_package.replace('.', '/') + '/' + filename

        try:
            response = requests.get(api_url, headers=self._auth_header)
            if response.status_code == 200:
                return response.text
            else:
                return None

        except:
            raise

    def write_file(self, target_package, filename, file_content, change_number):
        try:
            api_url =  self._base_url + self._url_path_file + target_package.replace('.', '/') + '/' + filename

            # Set our request header
            req_header = self._auth_header
            req_header.update({"X-CSRF-TOKEN": f"{self._csrf_token}"})
            req_header.update({"Cookie": f"{self._session_cookie}"})
            req_header.update({"SapBackPack":'{"Activated":true, "ChangeId":"' + str(change_number) + '"}'})
            req_header.update({"Orion-Version":"1.0"})
            req_header.update({"Content-Type": "text/plain"})
            req_header.update({"Accept": "*/*"})

            response = requests.put(api_url,
                                    data=file_content,
                                    headers = req_header)

            return response

        except:
            raise

    def create_package(self, parent_package, new_package):
        try:
            api_url =  self._base_url + self._url_path_file + parent_package.replace('.', '/')

            # Set our request header
            req_header = self._auth_header
            req_header.update({"X-CSRF-TOKEN": f"{self._csrf_token}"})
            req_header.update({"Cookie": f"{self._session_cookie}"})
            req_header.update({"Orion-Version":"1.0"})
            #req_header.update({"Content-Type": "text/plain"})
            req_header.update({"Accept": "*/*"})
            req_header.update({"Slug": f"{new_package.replace('.', '/')}"})

            response = requests.post(api_url,
                                     headers = req_header)

            return response

        except:
            raise

    def create_change(self, change_description):
        try:
            api_url =  self._base_url + self._url_path_change  

            # Set our request header
            req_header = self._auth_header
            req_header.update({"X-CSRF-TOKEN": f"{self._csrf_token}"})
            req_header.update({"Cookie": f"{self._session_cookie}"})
            req_header.update({"Orion-Version":"1.0"})
            req_header.update({"SapBackPack":'{"Description":"' + change_description + '"}'})

            response = requests.post(api_url,
                                     headers = req_header)

            return response

        except:
            raise

    def get_changes(self, filename_name):
        api_url =  self._base_url + self._url_path_change + '/' + filename_name

        try:
            response = requests.get(api_url, headers=self._auth_header)
            return response
        except:
            self._logger.error("Exception during read_file!!", exc_info=True)
            raise

    def create_schema(self, target_package, schema_name, change_id):
        schema_file_content = "// AutoGenerated on " + datetime.now().strftime("%Y%m%d %H:%M:%S") + " - ChangeID: " + change_id + "\n"
        schema_file_content += "schema_name = \"" + schema_name + "\";"

        file_name = schema_name + ".hdbschema"

        response = self.write_file(target_package, file_name, schema_file_content, change_id)

        return response

    def list_package(self, repo_package, depth=1):
        api_url =  self._base_url + self._url_path_file + repo_package.replace('.', '/') + f'/?depth={depth}'

        try:
            response = requests.get(api_url, headers=self._auth_header)
            return response
        except:
            raise

    def check_if_package_exists(self, package_name, create_if_not_exist=True):
        # check if the
        target_pkg = package_name.replace('.', '/')
        response = self.list_package(target_pkg)
        
        # if the response is not 200 then the directory doesn't exist. We should create it
        if (response.status_code != 200) and (create_if_not_exist == True):
            #Error returned, package doesn't exist, create it
            try:

                # Split the package name to find that existing package (parent) and new package
                parent_package, new_package = self.split_package_name(target_pkg)

                if (parent_package is None) or (new_package is None):
                    out_pkg_status = f"No existing parent package found: {target_pkg}"
                    return False, out_pkg_status
                else:
                    response = self.create_package(parent_package, new_package)
                    out_pkg_status = f"Package Created: {target_pkg}"
                    return True, out_pkg_status
            except Exception as e:
                out_pkg_status = f"Error while creating package - {e}"
                return False, out_pkg_status
        else:
            out_pkg_status = f"Package Exists: {target_pkg}"
            return True, out_pkg_status

    def split_package_name(self, package_name):
        # Make sure we've replaced . the /
        tmp_package_name = package_name.replace('.', '/')
        slash_pos = len(tmp_package_name)
        found = False

        while found == False and slash_pos >= 0:
            # Find the next "/" in the path
            slash_pos = tmp_package_name.rfind('/', 0, slash_pos)

            if slash_pos < 0:
                # We didn't find any more slashes, simply exit this check, the outer While statement should terminate
                pass
            else:
                str_left = tmp_package_name[0 : slash_pos ]
                str_right = tmp_package_name[slash_pos + 1 : ]

                # Check if the path to the left of the current slash exists
                response = self.list_package(str_left)
        
                # if the response is not 200 then the directory doesn't exist. We should create it
                if response.status_code == 200:
                    # The package exists
                    found = True

        # If we haven't found any existing packages the return None
        if found == False:
            return None, None
        else:
            return str_left, str_right


if __name__ == "__main__":
    hr = HanaRest("http://hxehost:8090", 'G986815', 'P@ssw0rd1')
    hr.split_package_name('bi.test_py.test_xxx_6.abc.def')